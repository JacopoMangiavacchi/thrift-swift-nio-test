/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


public func ==(lhs: SampleStruct, rhs: SampleStruct) -> Bool {
  return
    (lhs.key == rhs.key) &&
    (lhs.value == rhs.value)
}

extension SampleStruct : CustomStringConvertible {

  public var description : String {
    var desc = "SampleStruct("
    desc += "key=\(String(describing: self.key)), "
    desc += "value=\(String(describing: self.value))"
    return desc
  }

}

extension SampleStruct : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (key.hashValue)
    result = prime &* result &+ (value.hashValue)
    return result
  }

}

extension SampleStruct : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["key": 1, "value": 2, ]
  }

  public static var structName: String { return "SampleStruct" }

  public static func read(from proto: TProtocol) throws -> SampleStruct {
    _ = try proto.readStructBegin()
    var key: Int32!
    var value: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             key = try Int32.read(from: proto)
        case (2, .string):           value = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(key, named: "key")
    try proto.validateValue(value, named: "value")

    return SampleStruct(key: key, value: value)
  }

}



fileprivate final class TestService_Hello_args {

  fileprivate var HelloString: String


  fileprivate init(HelloString: String) {
    self.HelloString = HelloString
  }

}

fileprivate func ==(lhs: TestService_Hello_args, rhs: TestService_Hello_args) -> Bool {
  return
    (lhs.HelloString == rhs.HelloString)
}

extension TestService_Hello_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (HelloString.hashValue)
    return result
  }

}

extension TestService_Hello_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["HelloString": 1, ]
  }

  fileprivate static var structName: String { return "TestService_Hello_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TestService_Hello_args {
    _ = try proto.readStructBegin()
    var HelloString: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           HelloString = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(HelloString, named: "HelloString")

    return TestService_Hello_args(HelloString: HelloString)
  }

}



fileprivate final class TestService_Hello_result {

  fileprivate var success: String?


  fileprivate init() { }
  fileprivate init(success: String?) {
    self.success = success
  }

}

fileprivate func ==(lhs: TestService_Hello_result, rhs: TestService_Hello_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension TestService_Hello_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    return result
  }

}

extension TestService_Hello_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "TestService_Hello_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TestService_Hello_result {
    _ = try proto.readStructBegin()
    var success: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TestService_Hello_result(success: success)
  }

}



fileprivate final class TestService_GetSampleStruct_args {

  fileprivate var key: Int32

  fileprivate var value: String


  fileprivate init(key: Int32, value: String) {
    self.key = key
    self.value = value
  }

}

fileprivate func ==(lhs: TestService_GetSampleStruct_args, rhs: TestService_GetSampleStruct_args) -> Bool {
  return
    (lhs.key == rhs.key) &&
    (lhs.value == rhs.value)
}

extension TestService_GetSampleStruct_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (key.hashValue)
    result = prime &* result &+ (value.hashValue)
    return result
  }

}

extension TestService_GetSampleStruct_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["key": 1, "value": 2, ]
  }

  fileprivate static var structName: String { return "TestService_GetSampleStruct_args" }

  fileprivate static func read(from proto: TProtocol) throws -> TestService_GetSampleStruct_args {
    _ = try proto.readStructBegin()
    var key: Int32!
    var value: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             key = try Int32.read(from: proto)
        case (2, .string):           value = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(key, named: "key")
    try proto.validateValue(value, named: "value")

    return TestService_GetSampleStruct_args(key: key, value: value)
  }

}



fileprivate final class TestService_GetSampleStruct_result {

  fileprivate var success: SampleStruct?


  fileprivate init() { }
  fileprivate init(success: SampleStruct?) {
    self.success = success
  }

}

fileprivate func ==(lhs: TestService_GetSampleStruct_result, rhs: TestService_GetSampleStruct_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension TestService_GetSampleStruct_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    return result
  }

}

extension TestService_GetSampleStruct_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "TestService_GetSampleStruct_result" }

  fileprivate static func read(from proto: TProtocol) throws -> TestService_GetSampleStruct_result {
    _ = try proto.readStructBegin()
    var success: SampleStruct?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try SampleStruct.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return TestService_GetSampleStruct_result(success: success)
  }

}



extension TestServiceClient : TestService {

  private func send_Hello(HelloString: String) throws {
    try outProtocol.writeMessageBegin(name: "Hello", type: .call, sequenceID: 0)
    let args = TestService_Hello_args(HelloString: HelloString)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_Hello() throws -> String {
    try inProtocol.readResultMessageBegin() 
    let result = try TestService_Hello_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "Hello"))
  }

  public func Hello(HelloString: String) throws -> String {
    try send_Hello(HelloString: HelloString)
    try outProtocol.transport.flush()
    return try recv_Hello()
  }

  private func send_GetSampleStruct(key: Int32, value: String) throws {
    try outProtocol.writeMessageBegin(name: "GetSampleStruct", type: .call, sequenceID: 0)
    let args = TestService_GetSampleStruct_args(key: key, value: value)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_GetSampleStruct() throws -> SampleStruct {
    try inProtocol.readResultMessageBegin() 
    let result = try TestService_GetSampleStruct_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "GetSampleStruct"))
  }

  public func GetSampleStruct(key: Int32, value: String) throws -> SampleStruct {
    try send_GetSampleStruct(key: key, value: value)
    try outProtocol.transport.flush()
    return try recv_GetSampleStruct()
  }

}

extension TestServiceProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["Hello"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TestService_Hello_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TestService_Hello_result()
      do {
        result.success = try handler.Hello(HelloString: args.HelloString)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "Hello", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["GetSampleStruct"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try TestService_GetSampleStruct_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = TestService_GetSampleStruct_result()
      do {
        result.success = try handler.GetSampleStruct(key: args.key, value: args.value)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "GetSampleStruct", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = TestServiceProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

